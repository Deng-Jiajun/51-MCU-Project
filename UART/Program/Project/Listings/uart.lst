C51 COMPILER V9.60.0.0   UART                                                              03/24/2022 02:09:35 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Source\uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\uart.lst) TABS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include <reg51.h>
   2          #include "uart.h"
   3          #include "delay.h"
   4          #include "led.h"
   5          
   6          unsigned char buffer; // 用于暂存从 SBUF 读出的数据
   7          // 初始化串口通信
   8          void UartInit(void)
   9          {
  10   1          /* 配置串口通信 方式 1 */
  11   1          SCON = 0x50; // 方式1、允许接收、清标志位
  12   1          /* 👆等价👇
  13   1          SM0=0; SM1=1; // 方式 1
  14   1          REN=1;        // 允许接收
  15   1          TI=0; RI=0;   // 清标志位
  16   1          */
  17   1          // PCON |= 0x80; // 波特率增倍（PCON 最高位）❗12M
  18   1          ES = 1; // 允许串口中断
  19   1      
  20   1          /* 配置定时器 T1 方式 2 */
  21   1          TMOD &= 0x0F; //（高 4 位全置 0）
  22   1          TMOD |= 0x20; // 方式 2（8 位定时器）、定时模式、无需门控制
  23   1          TR1 = 1;      // 开启定时器 1
  24   1          // TL1 = 0xF9;   // 赋值初值 8 位（用于计数的初始值）波特率 9600❗12M
  25   1          // TH1 = 0xF9;   // 赋值初值 8 位（用于覆盖的初始值）波特率 9600❗12M
  26   1          TL1 = 0xFD; // ! 11.0592M
  27   1          TH1 = 0xFD; // ! 11.0592M
  28   1          TF1 = 0;    // 清标志位
  29   1      
  30   1          /* 配置定时器中断1（定时器1） */
  31   1          ET1 = 1; // 允许定时器 1 中断
  32   1          EA = 1;  // 打开总中断
  33   1          PT1 = 1; // 配置优先级，高
  34   1      }
  35          
  36          // 向串口发送一个字符
  37          void UartSendByte(unsigned char c)
  38          {
  39   1          SBUF = c;
  40   1          while (TI == 0) // 发送中断，Transmit Interrupt
  41   1              ;           // 等待，直到发送完成（发送完成 TI 会置 1）
  42   1          TI = 0;         // 清标志位（必须软件清零）
  43   1      }
  44          
  45          // 向串口发送一串字符串
  46          void UartSendString(unsigned char *s)
  47          {
  48   1          while (*s)
  49   1          {
  50   2              UartSendByte(*s++);
  51   2          }
  52   1      }
  53          
  54          unsigned char receivedByte; // 用于暂存从串口接收到的字符
C51 COMPILER V9.60.0.0   UART                                                              03/24/2022 02:09:35 PAGE 2   

  55          
  56          // 串口中断处理程序
  57          void UartIRQHandler(void) interrupt 4
  58          {
  59   1          UartSendByte('x');
  60   1          // 收发测试，接收到后原样返回
  61   1          // 接收数据
  62   1              ES = 0;        // 关闭中断，不允许再接收
  63   1              RI = 0;        // 接收中断清零
  64   1              buffer = SBUF; // 读出SBUF中的数据
  65   1              P0 = buffer;   // 直接写给 P0 端口（连着8盏灯）
  66   1              ES = 1;        // 打开中断，允许继续接收
  67   1              RI = 0;
  68   1      
  69   1              // 发送数据
  70   1              SBUF = buffer;
  71   1              while (TI == 0) //等待发送完成（发送完成 TI 会置 1）
  72   1                  ;
  73   1              TI = 0; // 发送中断清零
  74   1      
  75   1          // // UartSendString("UartIRQHandler\n");
  76   1          // if (RI) // 接收中断，Receive Interrupt
  77   1          // {
  78   1          //     // receivedByte = SBUF; // 读取字符
  79   1      
  80   1          //     // // 如果接收到「O」，点亮 LED0
  81   1          //     // if (receivedByte == 'O')
  82   1          //     // {
  83   1          //     //     TurnOnLED(0);
  84   1          //     // }
  85   1          //     // // 如果接收到「F」，关闭 LED0
  86   1          //     // if (receivedByte == 'F')
  87   1          //     // {
  88   1          //     //     TurnOffLED(0);
  89   1          //     // }
  90   1      
  91   1          //     // // 如果接收到「T」，点亮 LED1
  92   1          //     // if (receivedByte == 'T')
  93   1          //     // {
  94   1          //     //     TurnOnLED(1);
  95   1          //     // }
  96   1      
  97   1          //     // 处理完毕再清标志位
  98   1          //     RI = 0; // 清标志位（必须软件清零）
  99   1          // }
 100   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    112    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
