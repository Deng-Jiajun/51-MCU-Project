C51 COMPILER V9.60.0.0   IIC                                                               03/25/2022 11:15:20 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN .\Objects\iic.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Source\iic.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\iic.lst) TABS(2) OBJECT(.\Objects\iic.obj)

line level    source

   1          #include <reg51.h>
   2          #include <INTRINS.H>
   3          #include "iic.h"
   4          
   5          // IIC 延时 5μs
   6          void IIC_Dealy(void)
   7          {
   8   1          _nop_();
   9   1          _nop_();
  10   1          _nop_();
  11   1          _nop_();
  12   1          _nop_();
  13   1      }
  14          
  15          // IIC 主机发出起始信号 S
  16          void IIC_Start(void)
  17          {
  18   1          SCL = 1;
  19   1          SDA = 1;
  20   1          IIC_Dealy(); // 保持 SCL 高电平、SDA 高电平至少 4.7μs
  21   1      
  22   1          SDA = 0;
  23   1          IIC_Dealy(); // 保持 SCL 高电平、SDA 低电平至少 4.7μs
  24   1      }
  25          
  26          // IIC 主机发出中止信号 P
  27          void IIC_End(void)
  28          {
  29   1          SDA = 0; // 好像是要先写 SDA=0
  30   1          SCL = 1;
  31   1          IIC_Dealy(); // 保持 SCL 高电平、SDA 低电平至少 4μs
  32   1      
  33   1          SDA = 1;
  34   1          IIC_Dealy(); // 保持 SCL 高电平、SDA 高电平至少 4.7μs
  35   1      }
  36          
  37          // IIC 主机发送应答（应答 ACK 0 、非应答 NACK 1）
  38          void IIC_Send_ACK(bit ack)
  39          {
  40   1          /* 应答或者非应答，SCL 都是 低 → 高 → 低 */
  41   1      
  42   1          SCL = 0; // SCL 低
  43   1          IIC_Dealy();
  44   1      
  45   1          /* 应答，则 SDA 为低（0）；不应答，则 SDA 为高（1）
  46   1             注意，要先让 SDA 改变，然后再让 SCL 维持在高电平 */
  47   1          if (ack == ACK)
  48   1          {
  49   2              SDA = 0;     // SDA 低，应答
  50   2              IIC_Dealy(); // 这里应该不需要维持这么久
  51   2          }
  52   1          else
  53   1          {
  54   2              SDA = 1;     // SDA 高，非应答
C51 COMPILER V9.60.0.0   IIC                                                               03/25/2022 11:15:20 PAGE 2   

  55   2              IIC_Dealy(); // 这里应该不需要维持这么久
  56   2          }
  57   1      
  58   1          SCL = 1;     // SCL 高，它的维持期间才是真正表示 应答/非应答
  59   1                       // 即 SCL 为高电平时才表示数据有效
  60   1          IIC_Dealy(); // 维持至少 4μs
  61   1          SCL = 0;     // SCL 低，应答结束
  62   1      }
  63          
  64          // IIC 主机检查从机应答（接收数据）
  65          bit IIC_Check_ACK(void)
  66          {
  67   1      
  68   1          bit ack; //检测到的应答结果
  69   1          SCL = 0;
  70   1          IIC_Dealy(); // SCL 维持低电平一段时间再拉高
  71   1          SCL = 1;     // 进入数据有效期
  72   1      
  73   1          _nop_();
  74   1          _nop_(); // 稍微等待一段时间让电平稳定
  75   1      
  76   1          if (SDA == 0) // 应答
  77   1          {
  78   2      
  79   2              ack = ACK;
  80   2          }
  81   1          else //非应答
  82   1          {
  83   2              ack = NACK;
  84   2          }
  85   1      
  86   1          SCL = 0; // SCL 恢复低电平
  87   1          _nop_();
  88   1          _nop_(); // 稍微等待一段时间让电平稳定
  89   1      
  90   1          return ack;
  91   1      }
  92          
  93          // IIC 主机发送字符（字节）
  94          void IIC_Send_Byte(unsigned char c)
  95          {
  96   1          unsigned char i;
  97   1      
  98   1          // 逐位发送字符
  99   1          for (i = 0; i < 8; i++)
 100   1          {
 101   2              SCL = 0;     // 拉低 SCL 并稳定一段时间
 102   2              IIC_Dealy(); // 这里应该不需要维持这么久
 103   2      
 104   2              /* 字符一共 8 位，0000 0000，字符不断左移，每次都发送字符最高位 */
 105   2              SDA = (bit)(c & 0x80);
 106   2              IIC_Dealy(); // 等待 SDA 数据稳定
 107   2              c = c << 1;  // 最高位已经写入 SDA，字符左移，最高位变为下一位
 108   2                           //（最后 c 会变成 8 个 0）
 109   2      
 110   2              SCL = 1;     // 拉高 SCL，发送出这位数据
 111   2              IIC_Dealy(); // 再稳定一段时间
 112   2          }
 113   1          SCL = 0; // 然后拉低 SCL（最后一次循环需要拉低）
 114   1      }
 115          
 116          // IIC 主机接收字符（字节）
C51 COMPILER V9.60.0.0   IIC                                                               03/25/2022 11:15:20 PAGE 3   

 117          unsigned char IIC_Read_Byte(void)
 118          {
 119   1          unsigned char receivedByte = 0;
 120   1          unsigned char i;
 121   1      
 122   1          // 逐位接收字符
 123   1          for (i = 0; i < 8; i++)
 124   1          {
 125   2              SCL = 0;     // 拉低 SCL 并稳定一段时间
 126   2              IIC_Dealy(); // 这里应该不需要维持这么久
 127   2              SCL = 1;     // 再拉高 SCL，接收一位数据
 128   2      
 129   2              /* 字符一共 8 位，0000 0000，每次都把 SDA 写入最低位并左移
 130   2                 这里选择先字符左移，再写入当前位，好处是不用判断是不是最后一位
 131   2                 以 i=0 时无实际意义的左移操作为代价，减少 8 次判断 i==7 
 132   2                 和 IIC_Send_Byte 里的循环向对应，IIC_Send_Byte 是先读入再移位 */
 133   2              receivedByte <<= 1;                
 134   2              receivedByte |= (unsigned char)SDA;
 135   2      
 136   2              IIC_Dealy(); // 等一段时间
 137   2          }
 138   1          SCL = 0; // 然后拉低 SCL（最后一次循环需要拉低）
 139   1      
 140   1          return receivedByte;
 141   1          // return 'F';
 142   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    158    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
