C51 COMPILER V9.60.0.0   PCF8591                                                           03/26/2022 15:45:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE PCF8591
OBJECT MODULE PLACED IN .\Objects\pcf8591.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Source\pcf8591.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\pcf8591.lst) TABS(2) OBJECT(.\Objects\pcf8591.obj)

line level    source

   1          #include <reg51.h>
   2          #include "pcf8591.h"
   3          #include "iic.h"
   4          
   5          /**
   6           * @brief 控制字节（「写」地址）指明要写的设备，以及要进行「写」操作
   7           *
   8           * 1001 开头，A2=A1=A1=0，写为低电平，0
   9           *
  10           *
  11           */
  12          unsigned char ADDR_WRITE = 0x90;
  13          
  14          /**
  15           * @brief 控制字节（「读」地址）指明要读的设备，以及要进行「读」操作
  16           *
  17           * 1001 开头，A2=A1=A1=0，读为高电平，1
  18           *
  19           */
  20          unsigned char ADDR_READ = 0x91;
  21          
  22          
  23          // A/D 转换，成功返回 1，不成功返回 0，转换结果以指针形式返回 AD 值
  24          bit IIC_Read_ADC(unsigned char controlByte, unsigned char *ad)
  25          {
  26   1         bit result = 0; // 执行结果，默认失败
  27   1      
  28   1         IIC_Start();               // 起始信号
  29   1         IIC_Send_Byte(ADDR_WRITE); // 写入控制字节（写数据，指明目标设备）
  30   1      
  31   1         if (IIC_Check_ACK() == ACK) // 如果应答（找到了设备）
  32   1         {
  33   2            IIC_Send_Byte(controlByte |= 0x40); // 写入控制字节（向该设备说明模式）
  34   2                                                // 同时允许 D/A 输出
  35   2      
  36   2            if (IIC_Check_ACK() == ACK) // 如果应答
  37   2            {
  38   3               IIC_Start();                // 起始信号
  39   3               IIC_Send_Byte(ADDR_READ);   // 写入控制字节（读数据，指明目标设备）
  40   3               if (IIC_Check_ACK() == ACK) // 如果应答，可以接收数据
  41   3               {
  42   4                  *ad = IIC_Read_Byte(); // 读出 AD 值，写入 ad
  43   4                  IIC_Send_ACK(NACK);    // 不需要再接收了，返回非应答
  44   4      
  45   4                  result = 1; // 成功读取
  46   4               }
  47   3            }
  48   2         }
  49   1         IIC_End(); // 结束本次传输，发出中止信号
  50   1      
  51   1         return result; // 返回执行结果
  52   1      }
  53          
  54          // D/A 转换，成功返回 1，不成功返回 0，ad 是要转换的 AD 值
C51 COMPILER V9.60.0.0   PCF8591                                                           03/26/2022 15:45:55 PAGE 2   

  55          bit IIC_Write_DAC(unsigned char ad)
  56          {
  57   1         bit result = 0; // 执行结果，默认失败
  58   1      
  59   1         IIC_Start();               // 起始信号
  60   1         IIC_Send_Byte(ADDR_WRITE); // 写入控制字节（写数据，指明目标设备）
  61   1      
  62   1         if (IIC_Check_ACK() == ACK) // 如果应答（找到了设备）
  63   1         {
  64   2            IIC_Send_Byte(0x40); // 写入控制字节（D/A 输出）
  65   2                                 //! 这里直接写 0x40 应该会干扰 IIC_Read_ADC
  66   2      
  67   2            if (IIC_Check_ACK() == ACK) // 如果应答
  68   2            {
  69   3               // IIC_Start();                //? 起始信号，这里好像不需要再 start
  70   3               IIC_Send_Byte(ad);          // 写入控制字节（给出 AD 值）
  71   3               if (IIC_Check_ACK() == ACK) // 如果应答，则写入成功
  72   3               {
  73   4                  result = 1; // 成功写入
  74   4               }
  75   3            }
  76   2         }
  77   1         IIC_End(); // 结束本次传输，发出中止信号
  78   1      
  79   1         return result; // 返回执行结果
  80   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    122    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
